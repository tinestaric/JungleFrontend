var gdjs;(function(i){class S{constructor(){this.tasksWithCallback=new Array}processTasks(e){for(let t=0;t<this.tasksWithCallback.length;t++){const a=this.tasksWithCallback[t];a.asyncTask.update(e)&&(a.callback(e,a.longLivedObjectsList),this.tasksWithCallback.splice(t--,1))}}addTask(e,t,a,s){this.tasksWithCallback.push({asyncTask:e,callback:t,callbackId:a,longLivedObjectsList:s})}clearTasks(){this.tasksWithCallback.length=0}getNetworkSyncData(e){return{tasks:this.tasksWithCallback.map(({asyncTask:a,callbackId:s,longLivedObjectsList:o})=>a.getNetworkSyncData?{callbackId:s,asyncTask:a.getNetworkSyncData(),objectsList:o.getNetworkSyncData(e)}:null).filter(Boolean)}}updateFromNetworkSyncData(e,t,a,s){this.clearTasks();const o=[];e.tasks.forEach(({callbackId:y,asyncTask:n,objectsList:w})=>{if(!n)return;const u=t.get(y);if(u){const p=new i.LongLivedObjectsList;if(p.updateFromNetworkSyncData(w,a,s),n.type==="group"){const r=new l;r.updateFromNetworkSyncData(n),this.addTask(r,u,y,p)}else if(n.type==="wait"){const r=new i.evtTools.runtimeScene.WaitTask(n.duration);r.updateFromNetworkSyncData(n),this.addTask(r,u,y,p)}else o.push(n.type)}}),o.length&&console.warn(`${o.length} asynchronous task(s) could not be restored from network sync data. ${o.join(", ")}`)}}i.AsyncTasksManager=S;class c{}i.AsyncTask=c;class l extends c{constructor(){super(...arguments);this.tasks=new Array}addTask(e){this.tasks.push(e)}update(e){for(let t=0;t<this.tasks.length;t++)this.tasks[t].update(e)&&this.tasks.splice(t--,1);return this.tasks.length===0}getNetworkSyncData(){return{type:"group",tasks:this.tasks.map(e=>e.getNetworkSyncData())}}updateFromNetworkSyncData(e){const t=[];e.tasks.forEach(a=>{if(!!a)if(a.type==="group"){const s=new l;s.updateFromNetworkSyncData(a),this.addTask(s)}else if(a.type==="wait"){const s=new i.evtTools.runtimeScene.WaitTask(a.duration);s.updateFromNetworkSyncData(a),this.addTask(s)}else t.push(a.type)}),t.length&&console.warn(`${t.length} asynchronous task(s) could not be restored from network sync data. ${t.join(", ")}`)}}i.TaskGroup=l;class g extends c{update(){return!0}getNetworkSyncData(){return null}updateFromNetworkSyncData(e){}}i.ResolveTask=g;const d=new i.Logger("Internal PromiseTask");class h extends c{constructor(e){super();this.isResolved=!1;this.promise=e.catch(t=>{d.error(`A promise error has not been handled, this should never happen!
If you are using JavaScript promises in an asynchronous action, make sure to add a .catch().
Otherwise, report this as a bug on the GDevelop forums!
${t?"The following error was thrown: "+t:""}`)}).then(t=>(this.isResolved=!0,t))}update(){return this.isResolved}getNetworkSyncData(){return null}updateFromNetworkSyncData(e){}}i.PromiseTask=h;class D extends c{constructor(){super(...arguments);this.isResolved=!1}resolve(){this.isResolved=!0}update(){return this.isResolved}getNetworkSyncData(){return null}updateFromNetworkSyncData(e){}}i.ManuallyResolvableTask=D})(gdjs||(gdjs={}));
//# sourceMappingURL=AsyncTasksManager.js.map
